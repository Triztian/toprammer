#!/usr/bin/env python
"""
#    TOP2049 Open Source programming suite
#
#    Qt-based graphical user interface
#
#    Copyright (c) 2010 Michael Buesch <mb@bu3sch.de>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""

from libtoprammer.toprammer_main import *
from PyQt4.QtCore import *
from PyQt4.QtGui import *
import sys
import time


class GuiUserInterface(AbstractUserInterface):
	def __init__(self, hwThread):
		self.hwThread = hwThread

	def progressMeterInit(self, meterId, message, nrSteps):
		self.hwThread.appendMessage("progrInit", (meterId, message, nrSteps))

	def progressMeterFinish(self, meterId):
		self.hwThread.appendMessage("progrFinish", meterId)

	def progressMeter(self, meterId, step):
		self.hwThread.appendMessage("progress", (meterId, step))

	def __consoleMessage(self, message, newline=True):
		if newline:
			message += "\n"
		self.hwThread.appendMessage("console", message)

	def warningMessage(self, message, newline=True):
		self.__consoleMessage(message, newline)

	def infoMessage(self, message, newline=True):
		self.__consoleMessage(message, newline)

	def debugMessage(self, message, newline=True):
		self.__consoleMessage(message, newline)

class HwThread(QThread):
	TASK_SHUTDOWN		= 0
	TASK_INITCHIP		= 1
	TASK_READSIG		= 2
	TASK_ERASE		= 3
	TASK_READPROG		= 4
	TASK_WRITEPROG		= 5
	TASK_READEEPROM		= 6
	TASK_WRITEEEPROM	= 7
	TASK_READFUSE		= 8
	TASK_WRITEFUSE		= 9
	TASK_READLOCK		= 10
	TASK_WRITELOCK		= 11
	TASK_READALL		= 12

	def __init__(self, mainWindow):
		QThread.__init__(self, mainWindow)

		self.mainWindow = mainWindow
		self.killRequest = False
		self.messageQueue = []
		self.top = None
		self.task = None
		self.taskParameter = None

		self.pollTimer = QTimer(self)
		self.pollTimer.setSingleShot(False)
		self.connect(self.pollTimer, SIGNAL("timeout()"), self.__poll)

		self.waitCondition = QWaitCondition()
		self.mutex = QMutex()
		self.setTopParameters()
		self.start()

	def killThread(self):
		if self.isRunning():
			self.mutex.lock()
			self.task = self.TASK_SHUTDOWN
			self.killRequest = True
			self.waitCondition.wakeAll()
			self.mutex.unlock()
			self.wait()

	def setTopParameters(self, busDev=None, verbose=2, forceLevel=0,
			     usebroken=False, forceBitfileUpload=True):
		assert(self.top is None and self.task is None)
		self.param_busDev = busDev
		self.param_verbose = verbose
		self.param_forceLevel = forceLevel
		self.param_usebroken = usebroken
		self.param_forceBitfileUpload = forceBitfileUpload

	def triggerTask(self, task, taskParameter=None):
		self.mutex.lock()
		self.task = task
		self.taskParameter = taskParameter
		self.pollTimer.start(200)
		self.waitCondition.wakeAll()
		self.mutex.unlock()

	def run(self):
		self.mutex.lock()
		while True:
			if not self.killRequest and self.task is None:
				self.waitCondition.wait(self.mutex)
			self.mutex.unlock()
			self.__taskWorker()
			self.mutex.lock()
			if self.killRequest and self.task is None:
				break
		self.mutex.unlock()

	def appendMessage(self, message, data):
		if self.pollTimer.isActive():
			self.mutex.lock()
			self.messageQueue.append( (message, data) )
			self.mutex.unlock()

	def __taskWorker(self):
		try:
			result = self.__runTask(self.task)
			failed = False
		except (TOPException, Exception), e:
			result = e
			failed = True
		self.appendMessage("finished", (self.task, failed, result))
		self.task = None
		self.taskParameter = None

	def __runTask(self, task):
		retval = None
		if task == self.TASK_SHUTDOWN:
			print "TOP hardware shutdown..."
			if self.top:
				self.top.shutdownChip()
				self.top = None
			return retval
		if not self.top:
			# Initialize Hardware access
			self.top = TOP(busDev = self.param_busDev,
				       verbose = self.param_verbose,
				       forceLevel = self.param_forceLevel,
				       usebroken = self.param_usebroken,
				       forceBitfileUpload = self.param_forceBitfileUpload,
				       userInterface = GuiUserInterface(self))
		if task == self.TASK_INITCHIP:
			self.top.initializeChip(self.taskParameter)
			retval = Chip.getSupportFlags(self.top.getChip())
		elif task == self.TASK_READSIG:
			retval = self.top.readSignature()
		elif task == self.TASK_ERASE:
			self.top.eraseChip()
		elif task == self.TASK_READPROG:
			retval = self.top.readProgmem()
		elif task == self.TASK_WRITEPROG:
			self.top.writeProgmem(self.taskParameter)
		elif task == self.TASK_READEEPROM:
			retval = self.top.readEEPROM()
		elif task == self.TASK_WRITEEEPROM:
			self.top.writeEEPROM(self.taskParameter)
		elif task == self.TASK_READFUSE:
			retval = self.top.readFuse()
		elif task == self.TASK_WRITEFUSE:
			self.top.writeFuse(self.taskParameter)
		elif task == self.TASK_READLOCK:
			retval = self.top.readLockbits()
		elif task == self.TASK_WRITELOCK:
			self.top.writeLockbits(self.taskParameter)
		elif task == self.TASK_READALL:
			self.top.checkChip()
			sigImage = None
			progmemImage = None
			eepromImage = None
			fuseImage = None
			lockbitsImage = None
			supportFlags = Chip.getSupportFlags(self.top.getChip())
			if supportFlags & Chip.SUPPORT_SIGREAD:
				sigImage = self.top.readSignature()
			if supportFlags & Chip.SUPPORT_PROGMEMREAD:
				progmemImage = self.top.readProgmem()
			if supportFlags & Chip.SUPPORT_EEPROMREAD:
				eepromImage = self.top.readEEPROM()
			if supportFlags & Chip.SUPPORT_FUSEREAD:
				fuseImage = self.top.readFuse()
			if supportFlags & Chip.SUPPORT_LOCKREAD:
				lockbitsImage = self.top.readLockbits()
			retval = (sigImage, progmemImage, eepromImage, fuseImage, lockbitsImage)
		else:
			raise TOPException("INTERNAL ERROR: HwThread: unknown task")
		return retval

	def __poll(self):
		self.mutex.lock()
		for (message, data) in self.messageQueue:
			if message == "finished":
				self.pollTimer.stop()
				self.mainWindow.hardwareTaskFinished(
					task=data[0], failed=data[1], returnValue=data[2])
			elif message == "console":
				self.mainWindow.console.showMessage(data)
			elif message == "progrInit":
				(meterId, message, nrSteps) = data
				self.mainWindow.console.showMessage(message + "\n")
				self.mainWindow.console.progressMeterInit(meterId, nrSteps)
			elif message == "progrFinish":
				meterId = data
				self.mainWindow.console.progressMeter(meterId, -1)
			elif message == "progress":
				(meterId, step) = data
				self.mainWindow.console.progressMeter(meterId, step)
			else:
				assert(0)
		self.messageQueue = []
		self.mutex.unlock()

class Console(QDockWidget):
	def __init__(self, mainWindow):
		QDockWidget.__init__(self, mainWindow)

		self.setFeatures(self.DockWidgetMovable | self.DockWidgetFloatable)
		self.setWidget(QWidget(self))
		self.widget().show()
		self.widget().setLayout(QGridLayout(self.widget()))

		self.consoleMsgs = []
		self.consoleText = QPlainTextEdit(self)
		self.consoleText.setReadOnly(True)
		self.widget().layout().addWidget(self.consoleText, 0, 0)

		self.progress = QProgressBar(self)
		self.widget().layout().addWidget(self.progress, 1, 0)

	def __commitText(self):
		limit = 100
		if len(self.consoleMsgs) > limit:
			self.consoleMsgs.pop(0)
			assert(len(self.consoleMsgs) == limit)
		self.consoleText.setPlainText("".join(self.consoleMsgs))
		# Scroll to end
		scroll = self.consoleText.verticalScrollBar()
		scroll.setValue(scroll.maximum())

	def showMessage(self, message):
		message = str(message)
		if not message:
			return
		lastmsg = None
		if self.consoleMsgs:
			lastmsg = self.consoleMsgs[-1]
		if lastmsg and lastmsg[-1] != "\n":
			self.consoleMsgs[-1] = self.consoleMsgs[-1] + message
		else:
			self.consoleMsgs.append(message)
		self.__commitText()

	def progressMeterInit(self, meterId, nrSteps):
		if meterId != GuiUserInterface.PROGRESSMETER_CHIPACCESS:
			return
		self.progress.setMinimum(0)
		self.progress.setMaximum(max(0, nrSteps - 1))
		self.progress.setValue(self.progress.maximum())
		self.progress.setValue(0)

	def progressMeter(self, meterId, step):
		if meterId != GuiUserInterface.PROGRESSMETER_CHIPACCESS:
			return
		if step == -1:
			step = self.progress.maximum()
		if self.progress.maximum() == 0:
			self.progress.setMaximum(1)
			self.progress.setValue(1)
		else:
			self.progress.setValue(step)

class BufferWidget(QWidget):
	def __init__(self, mainWindow, name):
		QWidget.__init__(self, mainWindow)
		self.name = name
		self.hide()
		self.setLayout(QGridLayout(self))
		self.setReadOnly()

	def getName(self):
		return self.name

	def setReadOnly(self, readOnly=True):
		self.readOnly = readOnly

	def isReadOnly(self):
		return self.readOnly

	def getRawData(self):
		return None

	def setRawData(self, data):
		return False

class ImageBufferWidget(BufferWidget):
	def __init__(self, mainWindow, name):
		BufferWidget.__init__(self, mainWindow, name)

		self.browser = QPlainTextEdit(self)
		self.browser.setReadOnly(True)
		fmt = self.browser.currentCharFormat()
		fmt.setFontFamily("monospace")
		fmt.setFontFixedPitch(True)
		self.browser.setCurrentCharFormat(fmt)
		self.layout().addWidget(self.browser, 0, 0)

		self.image = None

	def __toAscii(self, char):
		if char >= 32 and char <= 126:
			return chr(char)
		return "."

	def loadImage(self, image):
		self.image = image
		text = []
		asc = []
		for i in range(0, len(image)):
			if i % 16 == 0:
				if i != 0:
					text.append("  |%s|\n" % "".join(asc))
					asc = []
				text.append("[%08X]: " % i)
			if i % 2 == 0:
				text.append(" %02X" % ord(image[i]))
			else:
				text.append("%02X" % ord(image[i]))
			asc.append(self.__toAscii(ord(image[i])))
		if asc:
			if len(image) % 16:
				nrLeft = 16 - (len(image) % 16)
				text.append("  " * nrLeft)
				text.append(" " * (nrLeft / 2))
			text.append("  |%s|" % "".join(asc))
		self.browser.setPlainText("".join(text))

	def getRawData(self):
		return self.image

	def setRawData(self, data):
		if self.isReadOnly():
			return False
		self.loadImage(data)
		return True

class BufferTabWidget(QTabWidget):
	def __init__(self, mainWindow):
		QTabWidget.__init__(self, mainWindow)

		self.progmemBuffer = ImageBufferWidget(mainWindow, "program memory")
		self.eepromBuffer = ImageBufferWidget(mainWindow, "(E)EPROM memory")

		self.setTabPosition(self.South)
		self.removeAll()

	def __removeAll(self):
		self.clear()
		self.progmemBuffer.hide()
		self.eepromBuffer.hide()

	def removeAll(self):
		self.__removeAll()

	def setupBuffers(self, chipSupportFlags):
		self.__removeAll()
		if chipSupportFlags & (Chip.SUPPORT_PROGMEMREAD | Chip.SUPPORT_PROGMEMWRITE):
			self.addTab(self.progmemBuffer, "Program memory")
			self.progmemBuffer.setReadOnly(
				not bool(chipSupportFlags & Chip.SUPPORT_PROGMEMWRITE))
		if chipSupportFlags & (Chip.SUPPORT_EEPROMREAD | Chip.SUPPORT_EEPROMWRITE):
			self.addTab(self.eepromBuffer, "(E)EPROM memory")
			self.eepromBuffer.setReadOnly(
				not bool(chipSupportFlags & Chip.SUPPORT_EEPROMWRITE))

	def loadBuffers(self, sigImage, progmemImage, eepromImage,
			fuseImage, lockbitsImage):
		if sigImage is not None:
			pass#TODO
		if progmemImage is not None:
			self.progmemBuffer.loadImage(progmemImage)
		if eepromImage is not None:
			self.eepromBuffer.loadImage(eepromImage)
		if fuseImage is not None:
			pass#TODO
		if lockbitsImage is not None:
			pass#TODO

	def getCurrentBuffer(self):
		return self.currentWidget()

class ChipSelectDialog(QDialog):
	def __init__(self, parent):
		QDialog.__init__(self, parent)
		self.setLayout(QGridLayout(self))

		self.chipList = QListWidget(self)
		for registeredChip in filter(lambda x: not x.broken, registeredChips):
			item = QListWidgetItem(registeredChip.description,
					       self.chipList)
			item.setData(Qt.UserRole, registeredChip)
		self.chipList.sortItems()
		self.layout().addWidget(self.chipList, 0, 0, 1, 2)

		self.okButton = QPushButton("&Ok", self)
		self.layout().addWidget(self.okButton, 1, 0)

		self.cancelButton = QPushButton("&Cancel", self)
		self.layout().addWidget(self.cancelButton, 1, 1)

		self.selectionChanged()

		self.connect(self.okButton, SIGNAL("released()"),
			     self.accept)
		self.connect(self.cancelButton, SIGNAL("released()"),
			     self.reject)
		self.connect(self.chipList, SIGNAL("itemSelectionChanged()"),
			     self.selectionChanged)
		self.connect(self.chipList, SIGNAL("itemDoubleClicked(QListWidgetItem)"),
			     self.accept)

	def selectionChanged(self):
		item = self.chipList.currentItem()
		self.okButton.setEnabled(bool(item))

	def getSelectedChip(self):
		item = self.chipList.currentItem()
		if not item:
			return None
		registeredChip = item.data(Qt.UserRole).toPyObject()
		return registeredChip.chipID

class StatusBar(QStatusBar):
	def __init__(self, mainWindow):
		QStatusBar.__init__(self, mainWindow)

class TopToolBar(QToolBar):
	def __init__(self, mainWindow):
		QToolBar.__init__(self, mainWindow)

		self.addAction("&Load\nbuffer", mainWindow.loadBuffer)
		self.addAction("S&ave\nbuffer", mainWindow.saveBuffer)
		self.addAction("&Select\nchip", mainWindow.selectChip)
		self.addSeparator()
		self.addAction("&Read\nchip", mainWindow.readChip)
		self.addAction("&Erase", mainWindow.eraseChip)
		self.addAction("Write\n&program\nmemory", mainWindow.writeChipProgmem)
		self.addAction("Write\n(E)EP&ROM", mainWindow.writeChipEeprom)
		self.addAction("Write\n&fuses", mainWindow.writeChipFuses)
		self.addAction("Write\n&lock bits", mainWindow.writeChipLockbits)

class LeftToolBar(QToolBar):
	def __init__(self, mainWindow):
		QToolBar.__init__(self, mainWindow)

class MainWindow(QMainWindow):
	def __init__(self, parent=None):
		QMainWindow.__init__(self, parent)
		self.setWindowTitle("TOPrammer - Open Source programming suite")

		self.chipSupportFlags = 0 # Chip.SUPPORT_... for the loaded chip

		self.setStatusBar(StatusBar(self))
		self.topToolBar = TopToolBar(self)
		self.addToolBar(Qt.TopToolBarArea, self.topToolBar)
		self.leftToolBar = LeftToolBar(self)
		self.addToolBar(Qt.LeftToolBarArea, self.leftToolBar)

		self.setMenuBar(QMenuBar(self))

		menu = QMenu("&File", self)
		menu.addAction("&Load buffer...", self.loadBuffer)
		menu.addAction("&Save buffer...", self.saveBuffer)
		menu.addSeparator()
		menu.addAction("&Exit", self.close)
		self.menuBar().addMenu(menu)

		menu = QMenu("&Run", self)
		menu.addAction("&Select chip", self.selectChip)
		menu.addSeparator()
		menu.addAction("&Read chip", self.readChip)
		menu.addAction("&Erase", self.eraseChip)
		menu.addAction("Write &program memory", self.writeChipProgmem)
		menu.addAction("Write (E)EP&ROM", self.writeChipEeprom)
		menu.addAction("Write &fuses", self.writeChipFuses)
		menu.addAction("Write &lock bits", self.writeChipLockbits)
		self.menuBar().addMenu(menu)

		menu = QMenu("&Help", self)
		menu.addAction("&About", self.showAbout)
		self.menuBar().addMenu(menu)

		self.bufferTab = BufferTabWidget(self)
		self.setCentralWidget(self.bufferTab)

		self.console = Console(self)
		self.addDockWidget(Qt.BottomDockWidgetArea, self.console)

		self.hwThread = HwThread(self)
		self.taskRunning = False

	def closeEvent(self, e):
		self.hwThread.killThread()
		e.accept()

	def showAbout(self):
		QMessageBox.information(self, "About TOPrammer",
			"Copyright (c) Michael Buesch <mb@bu3sch.de>")

	def loadBuffer(self):
		bufWidget = self.bufferTab.getCurrentBuffer()
		if not bufWidget:
			return
		if bufWidget.isReadOnly():
			QMessageBox.critical(self, "Buffer is read only",
				"Cannot load data into the %s buffer.\n"
				"The buffer is read-only." %\
				bufWidget.getName())
			return
		fn = QFileDialog.getOpenFileName(self,
			"%s - binary file" % bufWidget.getName())
		if not fn:
			return
		try:
			data = file(fn, "rb").read()
		except (IOError), e:
			QMessageBox.critical(self, "Failed to read file",
				"Failed to read %s:\n%s" %\
				(str(fn), str(e.strerror)))
			return
		bufWidget.setRawData(data)

	def saveBuffer(self):
		bufWidget = self.bufferTab.getCurrentBuffer()
		if not bufWidget:
			return
		data = bufWidget.getRawData()
		if not data:
			return
		fn = QFileDialog.getSaveFileName(self,
			"%s - binary file" % bufWidget.getName())
		if not fn:
			return
		try:
			file(fn, "wb").write(data)
		except (IOError), e:
			QMessageBox.critical(self, "Failed to write file",
				"Failed to write %s:\n%s" %\
				(str(fn), str(e.strerror)))
			return

	def selectChip(self):
		dlg = ChipSelectDialog(self)
		if dlg.exec_() == QDialog.Accepted:
			chipId = dlg.getSelectedChip()
			if chipId:
				self.runHardwareTask(HwThread.TASK_INITCHIP,
						     chipId)

	def readChip(self):
		self.runHardwareTask(HwThread.TASK_READALL)

	def eraseChip(self):
		self.runHardwareTask(HwThread.TASK_ERASE)

	def writeChipProgmem(self):
		pass#TODO

	def writeChipEeprom(self):
		pass#TODO

	def writeChipFuses(self):
		pass#TODO

	def writeChipLockbits(self):
		pass#TODO

	def guiUpdateEnable(self):
		self.menuBar().setEnabled(not self.taskRunning)
		self.topToolBar.setEnabled(not self.taskRunning)
		self.leftToolBar.setEnabled(not self.taskRunning)

	def runHardwareTask(self, task, taskParameter=None):
		assert(not self.taskRunning)
		self.console.progressMeterInit(GuiUserInterface.PROGRESSMETER_CHIPACCESS, 0)
		self.taskRunning = True
		self.guiUpdateEnable()
		self.hwThread.triggerTask(task, taskParameter)

	def hardwareTaskFinished(self, task, failed, returnValue):
		self.taskRunning = False
		if failed:
			self.console.showMessage("[HW op %d failed] %s\n" %\
					(task, str(returnValue)))
			self.console.progressMeterInit(GuiUserInterface.PROGRESSMETER_CHIPACCESS, 100)
			self.guiUpdateEnable()
			return
		# Task succeed
		if task == HwThread.TASK_SHUTDOWN:
			pass # Nothing to do
		elif task == HwThread.TASK_INITCHIP:
			self.chipSupportFlags = returnValue
			self.bufferTab.setupBuffers(self.chipSupportFlags)
		elif task == HwThread.TASK_READSIG:
			pass # Nothing to do
		elif task == HwThread.TASK_ERASE:
			pass # Nothing to do
		elif task == HwThread.TASK_READPROG:
			pass # Nothing to do
		elif task == HwThread.TASK_WRITEPROG:
			pass # Nothing to do
		elif task == HwThread.TASK_READEEPROM:
			pass # Nothing to do
		elif task == HwThread.TASK_WRITEEEPROM:
			pass # Nothing to do
		elif task == HwThread.TASK_READFUSE:
			pass # Nothing to do
		elif task == HwThread.TASK_WRITEFUSE:
			pass # Nothing to do
		elif task == HwThread.TASK_READLOCK:
			pass # Nothing to do
		elif task == HwThread.TASK_WRITELOCK:
			pass # Nothing to do
		elif task == HwThread.TASK_READALL:
			(sigImage, progmemImage, eepromImage, fuseImage, lockbitsImage) = returnValue
			self.bufferTab.setupBuffers(self.chipSupportFlags)
			self.bufferTab.loadBuffers(sigImage, progmemImage, eepromImage,
						   fuseImage, lockbitsImage)
		else:
			assert(0)
		self.console.showMessage("Ok.\n")
		self.console.progressMeter(GuiUserInterface.PROGRESSMETER_CHIPACCESS, -1)
		self.guiUpdateEnable()

def main():
	app = QApplication(sys.argv)
	mainwnd = MainWindow()
	mainwnd.show()
	return app.exec_()

if __name__ == "__main__":
	sys.exit(main())
